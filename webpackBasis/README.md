### sourceMap 提升开发体验
### 为什么：
    开发时运行的代码是经过webpack运行后的代码。如果代码出错，错误定位到的是编译后的代码，不便于修改。
### 是什么：
    sourceMap是一个用来生成源代码和构建后代码一一映射的文件的方案。它会生成一个xxx.map文件，里面包含源代码和构建后代码每一行，每一列的映射关系。当构建后代码出错了，会通过xxx.map文件，从构建后代码出错位置找到映射后源代码出错位置，从而让浏览器提示源代码文件出错位置，帮助我们更快的找到错误根源
### 怎么用：
    开发模式：cheap-module-source-map
    优点：打包编译速度快，只包含行映射
    缺点：没有列映射

    生产模式：source-map
    优点：包含行/列映射
    缺点：打包编译速度更慢

### HotModuleReplacement 提升打包构建速度
### 为什么
    开发时，我们修改了其中一个模块代码，webpack默认会将所有模块全部重新打包编译，速度很慢。所以我们需要做到修改某个模块代码，就只有这个模块代码需要重新打包编译，其他模块不变，这样打包速度就能很快。
### 是什么
    HotModuleReplacement（HMR/热模块替换）：在程序运行中，替换、添加或删除模块，而无需重新加载整个页面。
### 怎么用
    hot:true webpack默认开启
    实际开发中，vue和react脚手架会自动配置热模替换

### oneOf
### 为什么
    打包时每个文件都会经过所有loader处理，虽然因为test正则原因实际没有处理上，但是都要过一慢。
### 是什么
    当文件匹配上一个loader后，剩下的就不匹配了。

### Include/Exclude
### 为什么
    开发时我们需要使用第三方的库或插件，所有文件都下载到node_modules中了。而这些文件是不需要编译可以直接使用的。所以，我们在对js文件处理时，要排除node_modules下面的文件。
### 是什么
    include:包含，只处理xxx文件
    exclude:排除，除了xxx文件以外其他文件都处理

### cache
### 为什么
    每次打包时js文件都要经过eslint检查和babel编译，速度比较慢。我们可以缓存之前的eslint检查和babel编译结果，这样第二次打包时速度就会更快
### 是什么
    对eslint检查和babel编译结果进行缓存

### Thead
### 为什么
    当项目越来越庞大时，打包速度越来越慢。我们想继续提升打包速度，其实就是要提升js的打包速度，因为其他文件都比较少。而对js文件处理主要就是eslint\babel\terser三个工具，所以我们要提升它的运行速度。我们可以开启多进程同时处理js文件，这样速度就比之前的单进程打包更快了。

### 是什么
    多进程打包

### Tree Shaking  减少代码体积
### 为什么
    开发时我们定义了一些工具函数库，或者引用第三方工具函数库或组件库。如果没有特殊处理的话，我们打包时会引入整个库，但是实际上可能我们只用上极小部分的功能。这样将整个库都打包进来，体积就太大了。
### 怎么用
    webpack默认开启

### babel
### 为什么
    babel为编译的每个文件都插入了辅助代码，使代码体积过大。babel对一些公共方法使用了非常小的辅助代码，比如_extend。默认情况下会被添加到每一个需要它的文件中。假如有十个文件都用了_extend，那这个方法就被定义了十次。我们应该把这个方法单独定义成一个模块，来避免重复引入。
### 是什么
    @babel/plugin-transform-runtime:禁用了babel自动对每个文件的runtime注入，而是从@babel/plugin-transform-runtime引入辅助代码。
    
### Image minimizer
### 为什么
    开发如果项目中引用了较多图片，那么图片体积会比较大，将来请求速度比较慢。因此要对图片进行压缩，减少图片体积。注意：如果项目中图片都是在线链接，那就不需要了。本地项目静态图片才需要进行压缩。
### 是什么
    image-minimizer-webpack-plugin:用来压缩图片的插件

### code Split 优化代码运行性能
### 为什么
    打包代码时会将所有js文件打包到一个文件中，体积太大了。我们如果只想渲染首页，就应该只加在首页的js文件，其他文件不应该加载。所以我们需要将打包生成的文件进行代码分割，生成多个js文件，渲染哪个页面就只加载某个js文件，这样加载的资源就少，速度就更快。
### 是什么
    代码分割（Code Split）主要做了两件事：1、分割文件：将打包生成的文件进行分割，生成多个js文件。2、按需加载：需要哪个文件就加载哪个文件。 
### 怎么用
    多入口打包文件
    将复用的文件代码，单独打包
    对于页面中暂时不用的文件，先不打包。等要打包的时候再加载。

### Preload/Prefetch
### 为什么
    我们前面已经做了代码分割，同时会使用import动态导入语法来进行代码按需加载（我们也叫懒加载，比如路由懒加载就是这样实现的）。但是加载速度还不够好，比如：是拥护点击按钮时才加载这个资源的，如果资源体积很大，那么拥护会感觉明显卡顿效果。我们想在浏览器空闲时间，加载后继续使用的资源。我们就需要用上Preload或Prefetch技术。
### 是什么
    Preload:告诉浏览器立即加载资源
    Prefetch:告诉浏览器在空闲时才开始加载资源
    它们都只会加载资源，但不执行，并且都有缓存。它们的区别是Preload加载优先级高，Prefetch加载优先级低。Preload只能加载当前页面需要使用的资源，Prefetch可以加载当前页面资源，也可以加载下一个页面需要使用的资源。因此，当前页面优先级高的资源用Preload加载。下一个页面需要使用的资源用Prefetch加载。

### Core.js
### 为什么
    过去我们使用babel对js代码进行了兼容性处理，其中使用@babel/preset-env智能预设来处理兼容性问题。它能将ES6的一些语法进行编译转换，比如箭头函数，点点点运算符等。但是如果是async函数、promise对象、数组的一些方法（includes）等，它没办法处理。所以此时我们js代码仍然存在兼容性问题，一旦遇到低版本浏览器会直接报错。所以我们想要将js兼容性问题彻底解决。
### 是什么
    core-js是专门用来做ES6以及以上API的polyfill。polyfill翻译过来叫做补丁。就是用社区上提供的一段代码，让我们在不兼容某些新特性的浏览器上，使用该新特性。

### PWA
### 为什么
    开发Web App项目，项目一旦处于网络离线情况，就没法访问了。